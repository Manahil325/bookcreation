"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6802],{6817(n,i,e){e.r(i),e.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-digital-twins/chapter-2-unity-hri/digital-twin-creation","title":"Digital Twin Creation","description":"Creating digital twin models in Unity for robotics applications","source":"@site/docs/module-2-digital-twins/chapter-2-unity-hri/digital-twin-creation.md","sourceDirName":"module-2-digital-twins/chapter-2-unity-hri","slug":"/module-2-digital-twins/chapter-2-unity-hri/digital-twin-creation","permalink":"/docs/module-2-digital-twins/chapter-2-unity-hri/digital-twin-creation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-digital-twins/chapter-2-unity-hri/digital-twin-creation.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Digital Twin Creation","sidebar_position":2,"description":"Creating digital twin models in Unity for robotics applications","keywords":["digital twin","unity","robotics","simulation","3d modeling"],"learning_objectives":["Understand digital twin concepts and architecture","Create 3D models for digital twins","Implement physics and behaviors for digital twins","Connect digital twins to real-world data"],"estimated_time":"3 hours","difficulty":"Advanced","prerequisites":["Unity setup completed","Basic Unity 3D modeling concepts"]},"sidebar":"tutorialSidebar","previous":{"title":"Unity Setup","permalink":"/docs/module-2-digital-twins/chapter-2-unity-hri/unity-setup"},"next":{"title":"Human-Robot Interaction Concepts","permalink":"/docs/module-2-digital-twins/chapter-2-unity-hri/hri-concepts"}}');var s=e(4848),a=e(8453);const r={title:"Digital Twin Creation",sidebar_position:2,description:"Creating digital twin models in Unity for robotics applications",keywords:["digital twin","unity","robotics","simulation","3d modeling"],learning_objectives:["Understand digital twin concepts and architecture","Create 3D models for digital twins","Implement physics and behaviors for digital twins","Connect digital twins to real-world data"],estimated_time:"3 hours",difficulty:"Advanced",prerequisites:["Unity setup completed","Basic Unity 3D modeling concepts"]},o="Digital Twin Creation",l={},c=[{value:"Understanding Digital Twins",id:"understanding-digital-twins",level:2},{value:"Definition and Purpose",id:"definition-and-purpose",level:3},{value:"Key Components of a Digital Twin",id:"key-components-of-a-digital-twin",level:3},{value:"Benefits of Digital Twins in Robotics",id:"benefits-of-digital-twins-in-robotics",level:3},{value:"Creating Digital Twin Models",id:"creating-digital-twin-models",level:2},{value:"3D Model Preparation",id:"3d-model-preparation",level:3},{value:"Example: Importing a Robot Model",id:"example-importing-a-robot-model",level:3},{value:"Physics and Simulation",id:"physics-and-simulation",level:2},{value:"Physics Configuration",id:"physics-configuration",level:3},{value:"Realistic Physics Parameters",id:"realistic-physics-parameters",level:3},{value:"Example: Joint Configuration",id:"example-joint-configuration",level:3},{value:"Real-World Data Integration",id:"real-world-data-integration",level:2},{value:"Sensor Simulation",id:"sensor-simulation",level:3},{value:"Example: Camera Sensor Simulation",id:"example-camera-sensor-simulation",level:3},{value:"Synchronization with Physical Systems",id:"synchronization-with-physical-systems",level:2},{value:"State Synchronization",id:"state-synchronization",level:3},{value:"Example: State Synchronization",id:"example-state-synchronization",level:3},{value:"Validation and Calibration",id:"validation-and-calibration",level:2},{value:"Accuracy Validation",id:"accuracy-validation",level:3},{value:"Calibration Process",id:"calibration-process",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Exercise",id:"exercise",level:2}];function d(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"digital-twin-creation",children:"Digital Twin Creation"})}),"\n",(0,s.jsx)(i.p,{children:"Digital twins are virtual representations of physical systems that enable simulation, monitoring, and optimization. In this section, we'll explore how to create accurate digital twins in Unity for robotics applications."}),"\n",(0,s.jsx)(i.h2,{id:"understanding-digital-twins",children:"Understanding Digital Twins"}),"\n",(0,s.jsx)(i.h3,{id:"definition-and-purpose",children:"Definition and Purpose"}),"\n",(0,s.jsx)(i.p,{children:"A digital twin is a virtual representation of a physical object or system that spans its lifecycle. It uses real-time data and other sources to enable learning, reasoning, and dynamically calibrating for improved decision-making."}),"\n",(0,s.jsx)(i.h3,{id:"key-components-of-a-digital-twin",children:"Key Components of a Digital Twin"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Physical Twin"}),": The actual physical robot or system"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Virtual Twin"}),": The digital representation in Unity"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Connection"}),": Real-time data flow between physical and virtual twins"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Data"}),": Information about the physical twin's state, behavior, and environment"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"benefits-of-digital-twins-in-robotics",children:"Benefits of Digital Twins in Robotics"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Testing and Validation"}),": Test algorithms without risk to physical hardware"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Training"}),": Train AI models in safe, controlled environments"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Optimization"}),": Optimize robot behavior before deployment"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Maintenance"}),": Predictive maintenance and remote monitoring"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"creating-digital-twin-models",children:"Creating Digital Twin Models"}),"\n",(0,s.jsx)(i.h3,{id:"3d-model-preparation",children:"3D Model Preparation"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Importing CAD Models"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Export CAD models in compatible formats (FBX, OBJ, DAE)"}),"\n",(0,s.jsx)(i.li,{children:"Optimize polygon count for real-time performance"}),"\n",(0,s.jsx)(i.li,{children:"Ensure proper scale and coordinate systems"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Unity-Specific Considerations"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Use right-handed coordinate system (ROS uses right-handed, Unity uses left-handed)"}),"\n",(0,s.jsx)(i.li,{children:"Convert units if necessary (meters vs. Unity units)"}),"\n",(0,s.jsx)(i.li,{children:"Set up proper pivot points and origins"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"example-importing-a-robot-model",children:"Example: Importing a Robot Model"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\n\npublic class RobotModelSetup : MonoBehaviour\n{\n    public void SetupRobotModel()\n    {\n        // Ensure proper scaling\n        transform.localScale = new Vector3(1, 1, 1);\n\n        // Set up colliders for physics\n        SetupColliders();\n\n        // Configure joints and constraints\n        SetupJoints();\n    }\n\n    void SetupColliders()\n    {\n        // Add colliders to each robot link\n        foreach(Transform child in transform)\n        {\n            if(child.name.Contains("link"))\n            {\n                AddColliderToLink(child.gameObject);\n            }\n        }\n    }\n\n    void AddColliderToLink(GameObject link)\n    {\n        // Add appropriate collider based on link geometry\n        // Sphere, capsule, or mesh colliders as appropriate\n    }\n\n    void SetupJoints()\n    {\n        // Configure joints to match real robot kinematics\n        // Use ConfigurableJoint, HingeJoint, or other joint types\n    }\n}\n'})}),"\n",(0,s.jsx)(i.h2,{id:"physics-and-simulation",children:"Physics and Simulation"}),"\n",(0,s.jsx)(i.h3,{id:"physics-configuration",children:"Physics Configuration"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Rigid Body Setup"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Add Rigidbody components to movable parts"}),"\n",(0,s.jsx)(i.li,{children:"Configure mass, drag, and angular drag appropriately"}),"\n",(0,s.jsx)(i.li,{children:"Set up collision detection modes"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Joint Configuration"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Match joint limits to physical robot capabilities"}),"\n",(0,s.jsx)(i.li,{children:"Configure motor properties for actuated joints"}),"\n",(0,s.jsx)(i.li,{children:"Set up spring and damper parameters for compliance"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"realistic-physics-parameters",children:"Realistic Physics Parameters"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Mass"}),": Match the physical robot's mass distribution"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Friction"}),": Configure based on real-world contact surfaces"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Bounciness"}),": Typically very low for robot components"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Angular Velocity"}),": Limit to prevent unrealistic behavior"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"example-joint-configuration",children:"Example: Joint Configuration"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"using UnityEngine;\n\npublic class JointController : MonoBehaviour\n{\n    public ConfigurableJoint joint;\n    public float minAngle = -90f;\n    public float maxAngle = 90f;\n\n    void Start()\n    {\n        // Configure joint limits\n        SoftJointLimit limit = new SoftJointLimit();\n        limit.limit = maxAngle;\n        joint.highAngularXLimit = limit;\n\n        limit.limit = -minAngle;\n        joint.lowAngularXLimit = limit;\n\n        // Configure motor for actuation\n        JointDrive drive = new JointDrive();\n        drive.mode = JointDriveMode.Position;\n        drive.positionSpring = 10000f;\n        drive.positionDamper = 100f;\n        drive.maximumForce = 300f;\n\n        joint.slerpDrive = drive;\n    }\n\n    public void SetTargetRotation(float targetAngle)\n    {\n        joint.targetRotation = Quaternion.Euler(targetAngle, 0, 0);\n    }\n}\n"})}),"\n",(0,s.jsx)(i.h2,{id:"real-world-data-integration",children:"Real-World Data Integration"}),"\n",(0,s.jsx)(i.h3,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Camera Simulation"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Set up Unity cameras to match physical sensors"}),"\n",(0,s.jsx)(i.li,{children:"Configure field of view, resolution, and noise characteristics"}),"\n",(0,s.jsx)(i.li,{children:"Implement depth sensing capabilities"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"LIDAR Simulation"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Use raycasting to simulate LIDAR measurements"}),"\n",(0,s.jsx)(i.li,{children:"Configure scan parameters to match physical sensors"}),"\n",(0,s.jsx)(i.li,{children:"Implement noise and accuracy characteristics"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"example-camera-sensor-simulation",children:"Example: Camera Sensor Simulation"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing RosMessageTypes.Sensor;\n\npublic class CameraSensor : MonoBehaviour\n{\n    public Camera camera;\n    ROSConnection ros;\n    public string topicName = "camera/image_raw";\n\n    void Start()\n    {\n        ros = ROSConnection.GetOrCreateInstance();\n    }\n\n    void Update()\n    {\n        // Capture image and send to ROS\n        if (Time.frameCount % 30 == 0) // Send every 30 frames\n        {\n            SendImageToROS();\n        }\n    }\n\n    void SendImageToROS()\n    {\n        // Capture image from camera\n        RenderTexture currentRT = RenderTexture.active;\n        RenderTexture.active = camera.targetTexture;\n        camera.Render();\n\n        Texture2D image = new Texture2D(camera.targetTexture.width, camera.targetTexture.height);\n        image.ReadPixels(new Rect(0, 0, camera.targetTexture.width, camera.targetTexture.height), 0, 0);\n        image.Apply();\n\n        RenderTexture.active = currentRT;\n\n        // Convert and send to ROS\n        // (Implementation depends on specific ROS message format)\n    }\n}\n'})}),"\n",(0,s.jsx)(i.h2,{id:"synchronization-with-physical-systems",children:"Synchronization with Physical Systems"}),"\n",(0,s.jsx)(i.h3,{id:"state-synchronization",children:"State Synchronization"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Joint Position Synchronization"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Receive joint positions from physical robot"}),"\n",(0,s.jsx)(i.li,{children:"Update digital twin to match physical state"}),"\n",(0,s.jsx)(i.li,{children:"Handle communication delays and packet loss"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Environment Synchronization"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Update digital twin environment based on real-world changes"}),"\n",(0,s.jsx)(i.li,{children:"Synchronize lighting and other environmental factors"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"example-state-synchronization",children:"Example: State Synchronization"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing RosMessageTypes.Sensor;\n\npublic class StateSynchronizer : MonoBehaviour\n{\n    ROSConnection ros;\n    public string jointStateTopic = "joint_states";\n\n    void Start()\n    {\n        ros = ROSConnection.GetOrCreateInstance();\n        ros.Subscribe<JointStateMsg>(jointStateTopic, OnJointStateReceived);\n    }\n\n    void OnJointStateReceived(JointStateMsg jointState)\n    {\n        // Update digital twin joints to match physical robot\n        for (int i = 0; i < jointState.name.Count; i++)\n        {\n            string jointName = jointState.name[i];\n            float jointPosition = (float)jointState.position[i];\n\n            UpdateJoint(jointName, jointPosition);\n        }\n    }\n\n    void UpdateJoint(string jointName, float position)\n    {\n        // Find and update the corresponding joint in the digital twin\n        Transform jointTransform = transform.Find(jointName);\n        if (jointTransform != null)\n        {\n            // Update joint position/rotation\n            jointTransform.localEulerAngles = new Vector3(position * Mathf.Rad2Deg, 0, 0);\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(i.h2,{id:"validation-and-calibration",children:"Validation and Calibration"}),"\n",(0,s.jsx)(i.h3,{id:"accuracy-validation",children:"Accuracy Validation"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Visual Validation"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Compare visual output from physical and digital twins"}),"\n",(0,s.jsx)(i.li,{children:"Verify that both systems respond similarly to inputs"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Sensor Data Validation"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Compare sensor readings from both systems"}),"\n",(0,s.jsx)(i.li,{children:"Validate that simulation outputs match real-world data"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"calibration-process",children:"Calibration Process"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Parameter Adjustment"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Fine-tune physics parameters for accuracy"}),"\n",(0,s.jsx)(i.li,{children:"Adjust sensor noise models to match real data"}),"\n",(0,s.jsx)(i.li,{children:"Calibrate timing and synchronization"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Iterative Improvement"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Continuously compare and adjust"}),"\n",(0,s.jsx)(i.li,{children:"Document changes and their effects"}),"\n",(0,s.jsx)(i.li,{children:"Validate improvements quantitatively"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Model Accuracy"}),": Ensure digital twin accurately represents physical system"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Performance"}),": Balance accuracy with real-time performance requirements"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Maintainability"}),": Keep models organized and well-documented"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Scalability"}),": Design systems that can accommodate future expansion"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"exercise",children:"Exercise"}),"\n",(0,s.jsx)(i.p,{children:"Create a simple digital twin of a basic robot (e.g., a 2-DOF arm) in Unity. Implement basic physics, joint constraints, and connect it to a simulated ROS system. Validate that the digital twin accurately reflects the state of a simulated physical robot."})]})}function h(n={}){const{wrapper:i}={...(0,a.R)(),...n.components};return i?(0,s.jsx)(i,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453(n,i,e){e.d(i,{R:()=>r,x:()=>o});var t=e(6540);const s={},a=t.createContext(s);function r(n){const i=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function o(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),t.createElement(a.Provider,{value:i},n.children)}}}]);